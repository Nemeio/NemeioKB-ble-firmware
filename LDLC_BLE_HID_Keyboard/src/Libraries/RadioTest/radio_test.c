#include "radio_test.h"
#include "nrf_rng.h"

#define RADIO_LENGTH_LENGTH_FIELD (8UL) /**< Length on air of the LENGTH field. */
#define RADIO_MAX_PAYLOAD_LEN 256 /**< Maximum radio RX or TX payload. */

typedef enum {
	TRANSMIT_PATTERN_RANDOM, /**< Random pattern generated by RNG. */
	TRANSMIT_PATTERN_11110000, /**< Pattern 11110000(F0). */
	TRANSMIT_PATTERN_11001100, /**< Pattern 11001100(CC). */
} transmit_pattern_t;

static uint8_t m_tx_packet[RADIO_MAX_PAYLOAD_LEN]; /**< Buffer for the radio TX packet. */
static uint8_t g_rx_packet[RADIO_MAX_PAYLOAD_LEN];
volatile transmit_pattern_t g_pattern = TRANSMIT_PATTERN_RANDOM;

static uint32_t rnd8(void)
{
	nrf_rng_event_clear(NRF_RNG_EVENT_VALRDY);

	while (!nrf_rng_event_get(NRF_RNG_EVENT_VALRDY)) {
		/* Do nothing. */
	}

	return nrf_rng_random_value_get();
}

static uint32_t rnd32(void)
{
	uint32_t val = 0;

	for (uint8_t i = 0; i < 4; ++i) {
		val <<= 8;
		val |= rnd8();
	}
	return val;
}

static void radio_config(uint8_t mode)
{
	// Reset Radio ramp-up time.
	NRF_RADIO->MODECNF0 &= (~RADIO_MODECNF0_RU_Msk);

	// Packet configuration:
	// Bit 25: 1 Whitening enabled
	// Bit 24: 1 Big endian,
	// 4-byte base address length (5-byte full address length),
	// 0-byte static length, max 255-byte payload .
	NRF_RADIO->PCNF1 = (RADIO_PCNF1_WHITEEN_Enabled << RADIO_PCNF1_WHITEEN_Pos) |
			   (RADIO_PCNF1_ENDIAN_Big << RADIO_PCNF1_ENDIAN_Pos) |
			   (4UL << RADIO_PCNF1_BALEN_Pos) | (0UL << RADIO_PCNF1_STATLEN_Pos) |
			   ((sizeof(m_tx_packet) - 1) << RADIO_PCNF1_MAXLEN_Pos);
	NRF_RADIO->CRCCNF = (RADIO_CRCCNF_LEN_Disabled << RADIO_CRCCNF_LEN_Pos);

	NRF_RADIO->TXADDRESS = 0x00UL; // Set the device address 0 to use when transmitting
	NRF_RADIO->RXADDRESSES =
		0x01UL; // Enable the device address 0 to use to select which addresses to receive

	// Set the address according to the transmission pattern.
	switch (g_pattern) {
	case TRANSMIT_PATTERN_RANDOM:
		NRF_RADIO->PREFIX0 = rnd8();
		NRF_RADIO->BASE0 = rnd32();
		break;

	case TRANSMIT_PATTERN_11001100:
		NRF_RADIO->PREFIX0 = 0xCC;
		NRF_RADIO->BASE0 = 0xCCCCCCCC;
		break;

	case TRANSMIT_PATTERN_11110000:
		NRF_RADIO->PREFIX0 = 0xF0;
		NRF_RADIO->BASE0 = 0xF0F0F0F0;
		break;

	default:
		return;
	}

	switch (mode) {
#ifdef NRF52840_XXAA
	case RADIO_MODE_MODE_Ieee802154_250Kbit: {
		// Packet configuration:
		// S1 size = 0 bits, S0 size = 0 bytes, payload length size = 8 bits, 32-bit preamble.
		NRF_RADIO->PCNF0 = (RADIO_LENGTH_LENGTH_FIELD << RADIO_PCNF0_LFLEN_Pos) |
				   (RADIO_PCNF0_PLEN_32bitZero << RADIO_PCNF0_PLEN_Pos) |
				   (RADIO_PCNF0_CRCINC_Exclude << RADIO_PCNF0_CRCINC_Pos);
		NRF_RADIO->PCNF1 = (IEEE_MAX_PAYLOAD_LEN << RADIO_PCNF1_MAXLEN_Pos);

		NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast << RADIO_MODECNF0_RU_Pos);
	} break;

	case RADIO_MODE_MODE_Ble_LR500Kbit:
	case RADIO_MODE_MODE_Ble_LR125Kbit: {
		// Packet configuration:
		// S1 size = 0 bits, S0 size = 0 bytes, payload length size = 8 bits, 10-bit preamble.
		NRF_RADIO->PCNF0 = (0UL << RADIO_PCNF0_S1LEN_Pos) | (0UL << RADIO_PCNF0_S0LEN_Pos) |
				   (RADIO_PCNF0_PLEN_LongRange << RADIO_PCNF0_PLEN_Pos) |
				   (2UL << RADIO_PCNF0_CILEN_Pos) |
				   (3UL << RADIO_PCNF0_TERMLEN_Pos) |
				   (RADIO_PCNF0_CRCINC_Exclude << RADIO_PCNF0_CRCINC_Pos) |
				   (RADIO_LENGTH_LENGTH_FIELD << RADIO_PCNF0_LFLEN_Pos);
		NRF_RADIO->PCNF1 = (RADIO_PCNF1_WHITEEN_Enabled << RADIO_PCNF1_WHITEEN_Pos) |
				   (RADIO_PCNF1_ENDIAN_Little << RADIO_PCNF1_ENDIAN_Pos) |
				   (3UL << RADIO_PCNF1_BALEN_Pos) |
				   (0UL << RADIO_PCNF1_STATLEN_Pos) |
				   ((sizeof(m_tx_packet) - 1) << RADIO_PCNF1_MAXLEN_Pos);

		// Set fast ramp-up time.
		NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast << RADIO_MODECNF0_RU_Pos);

		// Set CRC length; CRC calculation does not include the address field.
		NRF_RADIO->CRCCNF = (RADIO_CRCCNF_LEN_Three << RADIO_CRCCNF_LEN_Pos) |
				    (RADIO_CRCCNF_SKIPADDR_Skip << RADIO_CRCCNF_SKIPADDR_Pos);
	} break;
#endif // NRF52840_XXAA

	case RADIO_MODE_MODE_Ble_2Mbit: {
		// Packet configuration:
		// S1 size = 0 bits, S0 size = 0 bytes, payload length size = 8 bits, 16-bit preamble.
		NRF_RADIO->PCNF0 = (0UL << RADIO_PCNF0_S1LEN_Pos) | (0UL << RADIO_PCNF0_S0LEN_Pos) |
				   (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) |
				   (RADIO_LENGTH_LENGTH_FIELD << RADIO_PCNF0_LFLEN_Pos);
	} break;

	default: {
		// Packet configuration:
		// S1 size = 0 bits, S0 size = 0 bytes, payload length size = 8 bits, 8 -bit preamble.
		NRF_RADIO->PCNF0 = (0UL << RADIO_PCNF0_S1LEN_Pos) | (0UL << RADIO_PCNF0_S0LEN_Pos) |
				   (RADIO_PCNF0_PLEN_8bit << RADIO_PCNF0_PLEN_Pos) |
				   (RADIO_LENGTH_LENGTH_FIELD << RADIO_PCNF0_LFLEN_Pos);
	} break;
	}
}

/**
 * @brief Function for configuring the radio to use a random address and a 254-byte random payload.
 * The S0 and S1 fields are not used.
 *
 * param[in] mode Radio mode.
 */
static void generate_modulated_rf_packet(uint8_t mode)
{
	radio_config(mode);

	// One byte used for size, actual size is SIZE-1
#ifdef NRF52840_XXAA
	if (mode == RADIO_MODE_MODE_Ieee802154_250Kbit) {
		m_tx_packet[0] = IEEE_MAX_PAYLOAD_LEN - 1;
	} else {
		m_tx_packet[0] = sizeof(m_tx_packet) - 1;
	}
#else
	m_tx_packet[0] = sizeof(m_tx_packet) - 1;
#endif // NRF52840_XXAA

	// Fill payload with random data.
	for (uint8_t i = 0; i < sizeof(m_tx_packet) - 1; i++) {
		if (g_pattern == TRANSMIT_PATTERN_RANDOM)
			m_tx_packet[i + 1] = rnd8();
		else if (g_pattern == TRANSMIT_PATTERN_11001100)
			m_tx_packet[i + 1] = 0xCC;
		else if (g_pattern == TRANSMIT_PATTERN_11110000)
			m_tx_packet[i + 1] = 0xF0;
		else {
			// Do nothing.
		}
	}
	NRF_RADIO->PACKETPTR = (uint32_t)m_tx_packet;
}

static void radio_disable(void)
{
	NRF_RADIO->SHORTS = 0;
	NRF_RADIO->EVENTS_DISABLED = 0;

	NRF_RADIO->TASKS_DISABLE = 1;

	while (NRF_RADIO->EVENTS_DISABLED == 0)
		;
	NRF_RADIO->EVENTS_DISABLED = 0;
}

static void radio_channel_set(uint8_t mode, uint8_t channel)
{
	NRF_RADIO->FREQUENCY = channel;
}

void radio_test_modulated_tx_carrier(uint8_t tx_power, uint8_t mode, uint8_t channel)
{
	radio_disable();
	generate_modulated_rf_packet(mode);

	switch (mode) {
#ifdef NRF52840_XXAA
	case RADIO_MODE_MODE_Ieee802154_250Kbit:
	case RADIO_MODE_MODE_Ble_LR125Kbit:
	case RADIO_MODE_MODE_Ble_LR500Kbit: {
		NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_PHYEND_START_Msk;
	} break;
#endif // NRF52840_XXAA

	case RADIO_MODE_MODE_Ble_1Mbit:
	case RADIO_MODE_MODE_Ble_2Mbit:
	case RADIO_MODE_MODE_Nrf_1Mbit:
	case RADIO_MODE_MODE_Nrf_2Mbit:
	default:
#ifdef NRF52832_XXAA
	case RADIO_MODE_MODE_Nrf_250Kbit:
#endif // NRF52832_XXAA
	{
		NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_START_Msk;
	} break;
	}
	NRF_RADIO->TXPOWER = (tx_power << RADIO_TXPOWER_TXPOWER_Pos);
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos);

	radio_channel_set(mode, channel);

	NRF_RADIO->TASKS_TXEN = 1;
}

void radio_test_rx(uint8_t mode, uint8_t channel)
{
	radio_disable();

	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos);
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_START_Msk;
	NRF_RADIO->PACKETPTR = (uint32_t)g_rx_packet;

	radio_config(mode);
	radio_channel_set(mode, channel);

	NRF_RADIO->TASKS_RXEN = 1U;
}

void radio_test_disable(void)
{
	radio_disable();
}

void radio_test_init(void)
{
	nrf_rng_task_trigger(NRF_RNG_TASK_STOP);
	nrf_rng_int_disable(NRF_RNG_INT_VALRDY_MASK);

	nrf_rng_task_trigger(NRF_RNG_TASK_START);
}